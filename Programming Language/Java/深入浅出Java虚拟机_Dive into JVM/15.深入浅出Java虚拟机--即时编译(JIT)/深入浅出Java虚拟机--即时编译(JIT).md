**修订记录**

| 时间 | 作者 | 内容 |
|--------|--------|--------|
| 2018.03.09 | 丁一 | 初稿 |

## 概述
如果一段java代码调用次数达到一定程度，就会被判定为热点代码，交给jit编译器即时编译为本地二进制代码，以提高运行速度。

Java 字节码是解释执行的，但是没有直接在 JVM 宿主执行原生代码快。为了提高性能，Oracle Hotspot 虚拟机会找到执行最频繁的字节码片段并把它们编译成原生机器码。编译出的原生机器码被存储在非堆内存的代码缓存中。通过这种方法，Hotspot 虚拟机将权衡下面两种时间消耗：将字节码编译成本地代码需要的额外时间和解释执行字节码消耗更多的时间。

## 编译器和解释器
当程序需要迅速启动和执行的时候，解释器可以发挥作用，省去编译时间，立即执行。
当程序运行后，编译器就可以把越来越多的代码编译成本地代码，以提高执行效率。

Hotspot虚拟机内置了两个即时编译器：

- Client Compiler，简称为C1编译器。获得更快的速度。
- Server Compiler，简称为C2编译器。获得更高的质量。

程序选择哪个编译器，取决于虚拟机的运行模式。HotSpot虚拟机会根据宿主机的性能自动运作运行模式，用户也可以在启动参数加上
“-client”或“-server”，强制指定运行模式。

编译器和解释器搭配使用的方式，被成为“混合模式”(Mixed Mode)。
用户可以使用参数“-Xint”，强制指定虚拟机只运行“解释模式”，也可以使用参数“-Xcomp”，强制虚拟机运行中在“编译模式”。

## 分层编译
分层编译会根据编译器编译、优化的模式和耗时，划分出不同的编译层次。
在JDK1.7，Server模式下，分层编译作为默认编译策略被开启。

- 第0层，程序解释执行，解释器不开启性能监控功能，可触发第1层编译。
- 第1层，也被成为C1编译，将字节码编译成本地代码，进行简单、可靠的优化，如有必要将加入性能监控。
- 第2层，也被成为C2编译，也是将字节码编译成本地代码，但是会开启一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的性能优化。

实施分层编译后，Client和Server编译器会同时工作，很多代码会多次编译，

## 编译对象与触发条件
### 热点代码
热点代码会被及时编译器进行编译，那么何为热点代码呢？

- 被多次调用的方法。
- 被多次执行的循环体。

虽然第二种情况是循环体，但编译器是以整个方法进行编译的，由于编译发生在方法执行过程中，也被称为栈上替换（on stack replacement, OSR）。

### 热点探测
判断一段代码是否是热点代码，需要使用热点探测技术。常用的技术有以下两种：

- 基于采样的探测技术：比如发现否个方法经常出现在栈顶，则这个方法就是热点方法。
- 基于计数器的探测技术： Hotspot默认使用，当计数器超过阀值，就会触发编译。

Hotspot虚拟机默认使用第二种方式，即 基于计数器的热点探测机制。

计数器分为：方法调用 和 **回边计数器** 。

#### 方法调用计数器
这种方式会统计方法调用次数。
在client模式下默认是1500次，server模式下是 10000次。可以通过**-XX: CompileThreshold** 参数修改。

当一个方法被调用时，先判断是否存在JIT编译过的版本，如果有，则调用本地编译代码执行。如果没有，则把计数器+1，然后判断：方法调用计数器 + 回边计数器 的值是否大于阀值，如果超过，则申请JIT热点编译。

默认情况下，执行引擎不会等待编译请求完成，而是会先调用解释器按照字节码方式执行，直到编译完成。这样下次调用就优先使用本地编译方式执行。

当方法调用计数器的值在一定时间范围内仍不等达到阀值，则计数器的值会衰减一半，它在GC时顺带执行。可以通过参数 
**-XX: -UseCounterDecay** 来关闭热度衰减。还可以通过 **-XX: CounterHalfLifeTime** 参数 设置半衰周期，单位是秒。

#### 回边计数器
统计方法体内循环体代码的调用次数。
在字节码中遇到控制流向后跳转的指令称为：回边（Back Edge）。主要用于栈上替换（OSR）
回边阀值可以通过参数：-XX: BackEdgeThreshhold 设置。但虚拟机并未支持。一般是通过参数：-XX: OnStackReplacPercentage 间接设置回边阀值。

回边计数器没有热度衰减。

## 编译过程
一般编译过程是在后台进行的，不会影响到正在解释执行的程序。 可以通过参数： -XX BackgroundCompilation 来禁止后台编译。
这样一旦提交编译请求，则会一直等待，直到编译完成。

后台编译阶段，Server compiler和Client compiler完成的工作是不一样的。

### client compiler
它是简单、快速的三段式编译器，会做局部优化。放弃耗时较长的全局优化。

### server compilier
它是一个充分优化的高级编译器。它会执行所有的优化动作。

## 查看和分析编译结果
由于编译后的机器码是0和1，人类无法阅读，需要使用反汇编工具编译成汇编语言进行查看。
把反汇编适配器放在/JRE/bin/client或者/server目录下，然后使用 -XX: PrintAssembly 打印编译后的汇编代码。










